module cyrus_protocol::types {
    use std::string::String;
    use std::vector;
    use aptos_framework::timestamp;

    /// Settlement instruction from source chain
    struct SettlementInstruction has copy, drop, store {
        source_chain: String,           // "solana", "ethereum", etc.
        source_tx_hash: String,         // Source chain transaction hash
        receiver: address,              // Aptos recipient address
        asset: String,                  // "USDC", "USDT", etc.
        amount: u64,                    // Amount in smallest unit (6 decimals for USDC)
        nonce: u64,                     // Unique nonce for this instruction
        timestamp: u64,                 // Timestamp from source chain
        fee: u64,                       // Processing fee
        relayer_fee: u64,              // Fee for relayer
    }

    /// Settlement result for tracking
    struct SettlementResult has copy, drop, store {
        instruction_id: String,         // Source transaction hash
        success: bool,                  // Whether settlement succeeded
        amount_settled: u64,           // Actual amount settled
        fee_collected: u64,            // Fee collected
        settlement_time: u64,          // When settlement was processed
        gas_used: u64,                 // Gas consumed
    }

    /// Vault statistics for monitoring
    struct VaultStats has copy, drop, store {
        total_deposits: u64,           // Total USDC deposited
        total_settlements: u64,        // Total settlements processed
        total_fees_collected: u64,     // Total fees collected
        vault_created_at: u64,         // Vault creation timestamp
        last_settlement_at: u64,       // Last settlement timestamp
        active_relayers: u64,          // Number of active relayers
    }

    /// Relayer information
    struct RelayerInfo has copy, drop, store {
        relayer_address: address,      // Relayer address
        authorized_at: u64,           // When relayer was authorized
        settlements_processed: u64,    // Number of settlements by this relayer
        fees_earned: u64,             // Total fees earned
        last_activity: u64,           // Last settlement timestamp
        is_active: bool,              // Whether relayer is currently active
    }

    /// Configuration parameters
    struct ProtocolConfig has copy, drop, store {
        protocol_fee_bps: u64,        // Protocol fee in basis points (100 = 1%)
        relayer_fee_bps: u64,         // Default relayer fee in basis points
        min_settlement_amount: u64,    // Minimum settlement amount
        max_settlement_amount: u64,    // Maximum settlement amount
        settlement_timeout: u64,       // Settlement timeout in seconds
        max_relayers: u64,            // Maximum number of relayers
    }

    /// Cross-chain token mapping
    struct TokenMapping has copy, drop, store {
        source_chain: String,          // Source chain name
        source_token: String,          // Source token identifier
        aptos_token_type: String,      // Aptos token type
        decimals: u8,                  // Token decimals
        min_amount: u64,              // Minimum transfer amount
        max_amount: u64,              // Maximum transfer amount
        is_active: bool,              // Whether mapping is active
    }

    // === Constructor Functions ===

    public fun new_settlement_instruction(
        source_chain: String,
        source_tx_hash: String,
        receiver: address,
        asset: String,
        amount: u64,
        nonce: u64,
        timestamp: u64,
        fee: u64,
        relayer_fee: u64,
    ): SettlementInstruction {
        SettlementInstruction {
            source_chain,
            source_tx_hash,
            receiver,
            asset,
            amount,
            nonce,
            timestamp,
            fee,
            relayer_fee,
        }
    }

    public fun new_settlement_result(
        instruction_id: String,
        success: bool,
        amount_settled: u64,
        fee_collected: u64,
        gas_used: u64,
    ): SettlementResult {
        SettlementResult {
            instruction_id,
            success,
            amount_settled,
            fee_collected,
            settlement_time: timestamp::now_microseconds(),
            gas_used,
        }
    }

    public fun new_relayer_info(
        relayer_address: address,
    ): RelayerInfo {
        RelayerInfo {
            relayer_address,
            authorized_at: timestamp::now_microseconds(),
            settlements_processed: 0,
            fees_earned: 0,
            last_activity: 0,
            is_active: true,
        }
    }

    public fun new_protocol_config(
        protocol_fee_bps: u64,
        relayer_fee_bps: u64,
        min_settlement_amount: u64,
        max_settlement_amount: u64,
        settlement_timeout: u64,
        max_relayers: u64,
    ): ProtocolConfig {
        ProtocolConfig {
            protocol_fee_bps,
            relayer_fee_bps,
            min_settlement_amount,
            max_settlement_amount,
            settlement_timeout,
            max_relayers,
        }
    }

    // === Getter Functions ===

    public fun get_instruction_amount(instruction: &SettlementInstruction): u64 {
        instruction.amount
    }

    public fun get_instruction_receiver(instruction: &SettlementInstruction): address {
        instruction.receiver
    }

    public fun get_instruction_hash(instruction: &SettlementInstruction): String {
        instruction.source_tx_hash
    }

    public fun get_instruction_nonce(instruction: &SettlementInstruction): u64 {
        instruction.nonce
    }

    public fun get_instruction_fee(instruction: &SettlementInstruction): u64 {
        instruction.fee
    }

    public fun get_result_success(result: &SettlementResult): bool {
        result.success
    }

    public fun get_result_amount(result: &SettlementResult): u64 {
        result.amount_settled
    }

    public fun get_relayer_settlements(info: &RelayerInfo): u64 {
        info.settlements_processed
    }

    public fun get_relayer_fees(info: &RelayerInfo): u64 {
        info.fees_earned
    }

    public fun is_relayer_active(info: &RelayerInfo): bool {
        info.is_active
    }

    // === Update Functions ===

    public fun update_relayer_activity(info: &mut RelayerInfo, settlements: u64, fees: u64) {
        info.settlements_processed = info.settlements_processed + settlements;
        info.fees_earned = info.fees_earned + fees;
        info.last_activity = timestamp::now_microseconds();
    }

    public fun activate_relayer(info: &mut RelayerInfo) {
        info.is_active = true;
    }

    public fun deactivate_relayer(info: &mut RelayerInfo) {
        info.is_active = false;
    }

    // === Validation Functions ===

    public fun validate_instruction(instruction: &SettlementInstruction, config: &ProtocolConfig): bool {
        // Check amount bounds
        instruction.amount >= config.min_settlement_amount &&
        instruction.amount <= config.max_settlement_amount &&
        // Check if timestamp is not too old (within settlement timeout)
        (timestamp::now_microseconds() - instruction.timestamp) <= config.settlement_timeout
    }

    public fun calculate_fees(amount: u64, config: &ProtocolConfig): (u64, u64) {
        let protocol_fee = (amount * config.protocol_fee_bps) / 10000;
        let relayer_fee = (amount * config.relayer_fee_bps) / 10000;
        (protocol_fee, relayer_fee)
    }

    // === Testing Utilities ===

    #[test_only]
    public fun create_test_instruction(): SettlementInstruction {
        new_settlement_instruction(
            std::string::utf8(b"solana"),
            std::string::utf8(b"test_tx_hash"),
            @0x123,
            std::string::utf8(b"USDC"),
            1000000, // 1 USDC
            1,
            timestamp::now_microseconds(),
            1000, // 0.001 USDC fee
            500,  // 0.0005 USDC relayer fee
        )
    }

    #[test_only]
    public fun create_test_config(): ProtocolConfig {
        new_protocol_config(
            10,      // 0.1% protocol fee
            5,       // 0.05% relayer fee  
            100000,  // 0.1 USDC minimum
            1000000000, // 1000 USDC maximum
            3600000000, // 1 hour timeout
            10,      // Max 10 relayers
        )
    }
}